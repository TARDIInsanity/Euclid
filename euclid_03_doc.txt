# -*- coding: utf-8 -*-
"""
Created on Sun May 15 16:59:33 2022

@author: TARDIInsanity
"""

2d program space
1d memory space
all integers
stack

this an interesting thought i had, actually
since i had a 2d program and 2d memory with a stack...
why not just change it to 1d memory, and i would get
a fusion of befunge, turing machine, and stack-based language!

behavior notes:
    popping from an empty stack or similar actions returns 0
    ` may substitute for \ for easier input when \ is an escape char
    empties:
        empty cells can be initialized with the . character
        no-op cells can be initialized with a space
        in practice, these are used exactly BACKWARDS
        because every no-op cell passed by the program is wasted time
        and every other empty cell is visual noise
    whenever the program pointer would move to an empty cell,
        it continues moving until it reaches a non-empty cell
    whenever a pointer would move off an array, it loops around
    user input beyond the first char is stored in a buffer
    
    
    
    pass

modular behavioral component dictionary:
    MODE instructions:
        s
            (stack) switch to stack mode
        p
            (prog) switch to program mode
        i
            (if) switch to if mode.
                when any instruction other than a MODE is evaluated:
                    pop a value off the stack.
                    if the value is 0, skip it
                    switch to program mode
        j
            (delay)
                perform the next instruction as though it were p
                then switch to if mode
                (especially useful for corner-turning conditions)
        m
            (mem) switch to memory mode
        g
            (alg) switch to algebra mode
    ?
        (s:inquire) push the stack length, push the input buffer length
        (p:inquire) push the x, then push the y coordinate
        (m:inquire) push the x coordinate
        (g:and) pop two values, bitwise and them, push the result
    =
        (s:swap) swap the last two values on the stack
        (p/m:nop) do nothing
        (g:equal) pop two values, push -1 if first = second, else 0
    <
        (s:dec) pop a value off the stack, decrement it, and push it back
        (p:left) set the program direction to left
        (m:lf) move the pointer left
        (g:less) pop a first, pop a second, push -1 if first < second, else 0
    >
        (s:inc) pop a value off the stack, increment it, and push it back
        (p:right) set the program direction to right
        (m:rt) move the pointer right
        (g:greater) pop a first, pop a second, push -1 if first > second, else 0
    ^
        (s:dup) pop a value off the stack and push it back twice
        (p:upward) set the program direction to up
        (m:push) push a copy of the current memory value to the stack
        (g:xor) pup two values, bitwise xor them, push the result
    v
        (s:drop) pop a value off the stack and discard it
        (p:down) set the program direction to down
        (m:pop) pop a value off the stack and replace the current memory value
        (g:leftshift) pop a target. pop a count.
            bitshift the target left by the count (multiply by 2**count) if count >= 0
            else bitshift the target right by -count (multiply by 2**count)
    /
        (s:inc) pop a value off the stack, increment it, and push it back
        (p:r1) reflect program movement direction across the line x=y
        (m:increment) increment the current memory cell
        (g:divmod) pop a divisor, pop a dividend
            push the remainder, push the integer quotient
    \
        (s:dec) pop a value off the stack, decrement it, and push it back
        (p:r2) reflect program movement direction across the line x=-y
        (m:decrement) decrement the current memory cell
        (g:abs) take the absolute value
    |
        (s/m:print) print an integer as a character
        (p:r3) reflect program movement direction across the line x=0
        (g:or) pop two values, bitwise or them, push the result
    -
        (s/m:neg) negate an integer
        (p:r4) reflect program movement direction across the line y=0
        (g:minus) pop a first, pop a second, push first-second
    x
        (s/m:not) invert an integer
        (p:r5) reverse program movement direction
        (g:mul) pop two values, multiply them, push the result
    +
        (s/m:input) take in the next input char as an integer
        (p:end) end computation
        (g:plus) pop two values, add them, push the result
    # - any digit from 0 to 9, a to f
        (s/m/g:set) push or write that number
        (p:skip) skip N program instructions

notes:
    0 - a = -a
    a < a = false = 0
    x ^ -1 = ~x
    x * -1 = -x
    -~x = x+1




    








